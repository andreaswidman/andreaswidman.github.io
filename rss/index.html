<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noindex, nofollow">
  <title>RSS</title>
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      overflow: hidden;
      background: #fff;
    }

    #feed {
      height: 100vh;
      overflow-y: auto;
      scroll-snap-type: y mandatory;
      scrollbar-width: none;
      overflow-anchor: none;
    }

    #feed::-webkit-scrollbar {
      display: none;
    }

    .post {
      height: 100vh;
      width: 100vw;
      scroll-snap-align: start;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10vh 0;
      background: #fff;
      position: relative;
    }

    .post img {
      max-width: 100%;
      max-height: 80vh;
      object-fit: contain;
    }

    .spinner {
      position: absolute;
      width: 24px;
      height: 24px;
      border: 2px solid #ddd;
      border-top-color: #999;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #loading-slide {
      height: 100vh;
      width: 100vw;
      scroll-snap-align: start;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    #auth {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fff;
      z-index: 10;
    }

    #auth input {
      font: 13px/1.4 system-ui, sans-serif;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 3px;
      outline: none;
    }

    #auth input:focus {
      border-color: #999;
    }
  </style>
</head>
<body>
  <div id="auth">
    <form>
      <input name="pass" type="password" autofocus>
    </form>
  </div>
  <main id="feed"></main>
  <script>
    history.scrollRestoration = 'manual';

    const CONFIG = {
      feeds: [
        'https://www.lifeonsundays.com',
        'http://jamiemclellan.tumblr.com',
        'http://randomitus.tumblr.com'
      ],
      proxy: 'https://api.allorigins.win/raw?url=',
      preloadAhead: 3
    };

    let currentIndex = 0;
    let isScrolling = false;
    let scrollingTimer;
    let feedExhausted = false;
    let pageNum = 1;
    let allImageUrls = [];
    let loadPromise = null;
    const preloaded = new Set();

    async function fetchFeed(feedUrl) {
      const res = await fetch(CONFIG.proxy + encodeURIComponent(feedUrl));
      return res.text();
    }

    function parseFeed(xml) {
      const doc = new DOMParser().parseFromString(xml, 'text/xml');
      return Array.from(doc.querySelectorAll('item'));
    }

    function pickBestSrc(img) {
      const srcset = img.getAttribute('srcset');
      if (!srcset) return img.getAttribute('src');
      const best = srcset.split(',')
        .map(s => {
          const [url, w] = s.trim().split(/\s+/);
          return { url, w: parseInt(w) || 0 };
        })
        .sort((a, b) => b.w - a.w);
      return best[0]?.url || img.getAttribute('src');
    }

    function extractItems(item) {
      const desc = item.querySelector('description');
      if (!desc) return [];
      const doc = new DOMParser().parseFromString(desc.textContent, 'text/html');
      const urls = Array.from(doc.querySelectorAll('img')).map(img => pickBestSrc(img)).filter(Boolean);
      const pubDate = item.querySelector('pubDate')?.textContent;
      const date = pubDate ? new Date(pubDate) : new Date(0);
      return urls.map(url => ({ url, date }));
    }

    function renderPosts(urls, startIndex) {
      const feed = document.getElementById('feed');
      urls.forEach((url, i) => {
        const idx = startIndex + i;
        const article = document.createElement('article');
        article.className = 'post';
        article.dataset.index = idx;

        const spinner = document.createElement('div');
        spinner.className = 'spinner';
        article.appendChild(spinner);

        const img = document.createElement('img');
        img.src = url;
        img.alt = '';
        img.loading = idx < 2 ? 'eager' : 'lazy';
        img.onload = () => spinner.remove();
        article.appendChild(img);
        const slide = document.getElementById('loading-slide');
        if (slide) feed.insertBefore(article, slide);
        else feed.appendChild(article);
      });
    }

    function navigateTo(index) {
      const posts = document.querySelectorAll('.post');
      const clamped = Math.max(0, Math.min(index, posts.length - 1));
      currentIndex = clamped;
      isScrolling = true;
      const feed = document.getElementById('feed');
      feed.scrollTo({ top: clamped * window.innerHeight, behavior: 'smooth' });
      preloadAround(clamped);
      // Safety: always release isScrolling even if scrollend never fires
      clearTimeout(scrollingTimer);
      scrollingTimer = setTimeout(() => { isScrolling = false; }, 800);
    }

    function observeScroll() {
      const feed = document.getElementById('feed');
      let scrollTimer;
      feed.addEventListener('scroll', () => {
        if (isScrolling) return;
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          currentIndex = Math.round(feed.scrollTop / window.innerHeight);
          preloadAround(currentIndex);
          if (currentIndex >= allImageUrls.length - 5) loadNextPage();
        }, 100);
      });
      feed.addEventListener('scrollend', () => { isScrolling = false; });
      if (!('onscrollend' in window)) {
        let endTimer;
        feed.addEventListener('scroll', () => {
          clearTimeout(endTimer);
          endTimer = setTimeout(() => { isScrolling = false; }, 150);
        });
      }
    }

    function preloadAround(index) {
      const end = Math.min(allImageUrls.length, index + CONFIG.preloadAhead + 1);
      for (let i = index; i < end; i++) {
        if (!preloaded.has(i)) {
          new Image().src = allImageUrls[i];
          preloaded.add(i);
        }
      }
    }

    function addLoadingSlide() {
      const feed = document.getElementById('feed');
      const slide = document.createElement('article');
      slide.id = 'loading-slide';
      const spinner = document.createElement('div');
      spinner.className = 'spinner';
      slide.appendChild(spinner);
      feed.appendChild(slide);
      return slide;
    }

    function loadNextPage() {
      if (feedExhausted) return Promise.resolve();
      if (loadPromise) return loadPromise;
      loadPromise = (async () => {
        console.log('[feed] loading page', pageNum);
        const startIndex = allImageUrls.length;

        // Fetch all feeds in parallel
        const results = await Promise.allSettled(
          CONFIG.feeds.map(base => {
            const feedUrl = pageNum === 1 ? base + '/rss' : base + '/page/' + pageNum + '/rss';
            return fetchFeed(feedUrl).then(xml => parseFeed(xml).flatMap(item => extractItems(item)));
          })
        );

        const newItems = [];
        let fetchError = false;
        for (const result of results) {
          if (result.status === 'fulfilled') newItems.push(...result.value);
          else { console.warn('Feed error:', result.reason); fetchError = true; }
        }

        pageNum++;
        loadPromise = null;

        if (newItems.length === 0) {
          if (!fetchError) {
            feedExhausted = true;
            document.getElementById('loading-slide')?.remove();
          }
          return;
        }

        // Merge chronologically â€” newest first
        newItems.sort((a, b) => b.date - a.date);
        const newUrls = newItems.map(i => i.url);

        allImageUrls.push(...newUrls);
        renderPosts(newUrls, startIndex);
        console.log('[feed] loaded', newUrls.length, 'images at index', startIndex);
        preloadAround(startIndex);
        return startIndex;
      })();
      return loadPromise;
    }

    document.addEventListener('keydown', async e => {
      if (e.key === 'j' || e.key === 'J') {
        if (currentIndex >= allImageUrls.length - 1) {
          const slide = document.getElementById('loading-slide');
          if (slide) {
            slide.scrollIntoView({ behavior: 'smooth' });
            const startIdx = await loadNextPage();
            if (startIdx != null) navigateTo(startIdx);
          }
        } else {
          if (currentIndex >= allImageUrls.length - 5) loadNextPage();
          navigateTo(currentIndex + 1);
        }
      }
      if (e.key === 'k' || e.key === 'K') navigateTo(currentIndex - 1);
    });

    const AUTH = btoa('pansy');
    const authEl = document.getElementById('auth');

    function observeLoadingSlide() {
      const slide = document.getElementById('loading-slide');
      if (!slide) return;
      const observer = new IntersectionObserver(entries => {
        if (entries[0].isIntersecting && currentIndex >= allImageUrls.length - 1) {
          loadNextPage();
        }
      }, { root: document.getElementById('feed'), threshold: 0.1 });
      observer.observe(slide);
    }

    async function startApp() {
      authEl.remove();
      addLoadingSlide();
      await loadNextPage();
      document.getElementById('feed').scrollTop = 0;
      observeScroll();
      observeLoadingSlide();
    }

    if (sessionStorage.getItem('rss-auth')) {
      startApp();
    } else {
      authEl.querySelector('form').addEventListener('submit', e => {
        e.preventDefault();
        if (btoa(e.target.pass.value) === AUTH) {
          sessionStorage.setItem('rss-auth', '1');
          startApp();
        } else {
          e.target.pass.value = '';
        }
      });
    }
  </script>
</body>
</html>
